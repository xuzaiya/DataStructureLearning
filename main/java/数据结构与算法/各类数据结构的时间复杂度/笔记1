1.顺序存储结构的效率分析
    顺序存储结构底层是利用数组来实现的，而数组可以存储具有相同数据类型的元素集合，如int，float或者自定义类型等，
    当我们创建一个数组时，计算机操作系统会为该数组分配一块连续的内存块，这也就意味着数组中的每个存储单元的地址都
    是连续的，因此只要知道了数组的起始内存地址就可以通过简单的乘法和加法计算出数组中第n-1个存储单元的内存地址，

    顺序表的访问操作(获取和修改元素值)的时间复杂为O(1)
    在等概率的情况下，插入或者删除一个顺序表的元素平均需要移动顺序表元素总量的一半，其时间复杂度是O(n)。
    然如果在插入时，内部数组容量不足时，也会造成其他开销，如复制元素的时间开销和新建数组的空间开销。

    优点:
        使用数组作为内部容器简单且易用
        在访问元素方面效率高
        数组具有内存空间局部性的特点，由于本身定义为连续的内存块，所以任何元素与其相邻的元素在物理地址上也是相邻的。
    缺点:
        内部数组大小是静态的，在使用前必须指定大小，如果遇到容量不足时，需动态拓展内部数组的大小，会造成额外的时间和空间开销
        在内部创建数组时提供的是一块连续的空间块，当规模较大时可能会无法分配数组所需要的内存空间
        顺序表的插入和删除是基于位置的操作，如果需要在数组中的指定位置插入或者删除元素，可能需要移动内部数组中的其他元素，这样会造成较大的时间开销，时间复杂度为O(n)

2.链表存储结构的效率分析
    出现原因：
        通过前面对线性顺序表的分析，我们知道当创建顺序表时必须分配一块连续的内存存储空间，而当顺序表内部数组的容量不足时，
        则必须创建一个新的数组，然后把原数组的的元素复制到新的数组中，这将浪费大量的时间。而在插入或删除元素时，
        可能需要移动数组中的元素，这也将消耗一定的时间。鉴于这种种原因，于是链表就出场了，链表在初始化时仅需要分配一个元素
        的存储空间，并且插入和删除新的元素也相当便捷，同时链表在内存分配上可以是不连续的内存，也不需要做任何内存复制和重新
        分配的操作

    2.1单链表的存储结构的效率分析
        查询和修改操作的时间复杂度是O(n)
        头结点处插入操作时间复杂度是O(1)
        某个节点插入的操作时间复杂度是O(n) (都是查询消耗的时间，同下)
        删除某个节点的操作时间复杂度是O(n)

    2.2双链表的存储结构的效率分析
    出现原因：
        在单链表分析中，我们可以知道每个结点只有一个指向后继结点的next域，倘若此时已知当前结点p，需要查找其前驱结点，
        那么就必须从head头指针遍历至p的前驱结点，操作的效率很低，因此如果p有一个指向前驱结点的next域，那效率就高多了，
        对于这种一个结点中分别包含了前驱结点域pre和后继结点域next的链表，称之为双链表。本篇我们将从以下结点来分析双链表
